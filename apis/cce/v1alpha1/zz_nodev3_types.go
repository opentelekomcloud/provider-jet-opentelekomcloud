/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type NodeV3DataVolumesObservation struct {
}

type NodeV3DataVolumesParameters struct {

	// +kubebuilder:validation:Optional
	ExtendParam *string `json:"extendParam,omitempty" tf:"extend_param,omitempty"`

	// +kubebuilder:validation:Optional
	KMSID *string `json:"kmsId,omitempty" tf:"kms_id,omitempty"`

	// +kubebuilder:validation:Required
	Size *int64 `json:"size" tf:"size,omitempty"`

	// +kubebuilder:validation:Required
	Volumetype *string `json:"volumetype" tf:"volumetype,omitempty"`
}

type NodeV3Observation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	PublicIP *string `json:"publicIp,omitempty" tf:"public_ip,omitempty"`

	ServerID *string `json:"serverId,omitempty" tf:"server_id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type NodeV3Parameters struct {

	// +kubebuilder:validation:Optional
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// +kubebuilder:validation:Required
	AvailabilityZone *string `json:"availabilityZone" tf:"availability_zone,omitempty"`

	// +kubebuilder:validation:Optional
	BandwidthChargeMode *string `json:"bandwidthChargeMode,omitempty" tf:"bandwidth_charge_mode,omitempty"`

	// +kubebuilder:validation:Optional
	BandwidthSize *int64 `json:"bandwidthSize,omitempty" tf:"bandwidth_size,omitempty"`

	// +kubebuilder:validation:Optional
	BillingMode *int64 `json:"billingMode,omitempty" tf:"billing_mode,omitempty"`

	// +kubebuilder:validation:Required
	ClusterID *string `json:"clusterId" tf:"cluster_id,omitempty"`

	// +kubebuilder:validation:Required
	DataVolumes []NodeV3DataVolumesParameters `json:"dataVolumes" tf:"data_volumes,omitempty"`

	// +kubebuilder:validation:Optional
	DockerBaseSize *int64 `json:"dockerBaseSize,omitempty" tf:"docker_base_size,omitempty"`

	// +kubebuilder:validation:Optional
	DockerLvmConfigOverride *string `json:"dockerLvmConfigOverride,omitempty" tf:"docker_lvm_config_override,omitempty"`

	// +kubebuilder:validation:Optional
	EIPCount *int64 `json:"eipCount,omitempty" tf:"eip_count,omitempty"`

	// +kubebuilder:validation:Optional
	EIPIds []*string `json:"eipIds,omitempty" tf:"eip_ids,omitempty"`

	// +kubebuilder:validation:Optional
	EcsPerformanceType *string `json:"ecsPerformanceType,omitempty" tf:"ecs_performance_type,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendParamChargingMode *int64 `json:"extendParamChargingMode,omitempty" tf:"extend_param_charging_mode,omitempty"`

	// +kubebuilder:validation:Required
	FlavorID *string `json:"flavorId" tf:"flavor_id,omitempty"`

	// +kubebuilder:validation:Optional
	Iptype *string `json:"iptype,omitempty" tf:"iptype,omitempty"`

	// +kubebuilder:validation:Optional
	K8STags map[string]*string `json:"k8sTags,omitempty" tf:"k8s_tags,omitempty"`

	// +kubebuilder:validation:Required
	KeyPair *string `json:"keyPair" tf:"key_pair,omitempty"`

	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MaxPods *int64 `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// +kubebuilder:validation:Optional
	OrderID *string `json:"orderId,omitempty" tf:"order_id,omitempty"`

	// +kubebuilder:validation:Optional
	Os *string `json:"os,omitempty" tf:"os,omitempty"`

	// +kubebuilder:validation:Optional
	Postinstall *string `json:"postinstall,omitempty" tf:"postinstall,omitempty"`

	// +kubebuilder:validation:Optional
	Preinstall *string `json:"preinstall,omitempty" tf:"preinstall,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// +kubebuilder:validation:Optional
	ProductID *string `json:"productId,omitempty" tf:"product_id,omitempty"`

	// +kubebuilder:validation:Optional
	PublicKey *string `json:"publicKey,omitempty" tf:"public_key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Required
	RootVolume []NodeV3RootVolumeParameters `json:"rootVolume" tf:"root_volume,omitempty"`

	// +kubebuilder:validation:Optional
	Sharetype *string `json:"sharetype,omitempty" tf:"sharetype,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	Taints []NodeV3TaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`
}

type NodeV3RootVolumeObservation struct {
}

type NodeV3RootVolumeParameters struct {

	// +kubebuilder:validation:Optional
	ExtendParam *string `json:"extendParam,omitempty" tf:"extend_param,omitempty"`

	// +kubebuilder:validation:Required
	Size *int64 `json:"size" tf:"size,omitempty"`

	// +kubebuilder:validation:Required
	Volumetype *string `json:"volumetype" tf:"volumetype,omitempty"`
}

type NodeV3TaintsObservation struct {
}

type NodeV3TaintsParameters struct {

	// +kubebuilder:validation:Required
	Effect *string `json:"effect" tf:"effect,omitempty"`

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// NodeV3Spec defines the desired state of NodeV3
type NodeV3Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NodeV3Parameters `json:"forProvider"`
}

// NodeV3Status defines the observed state of NodeV3.
type NodeV3Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NodeV3Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// NodeV3 is the Schema for the NodeV3s API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,otcjet}
type NodeV3 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NodeV3Spec   `json:"spec"`
	Status            NodeV3Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NodeV3List contains a list of NodeV3s
type NodeV3List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NodeV3 `json:"items"`
}

// Repository type metadata.
var (
	NodeV3_Kind             = "NodeV3"
	NodeV3_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NodeV3_Kind}.String()
	NodeV3_KindAPIVersion   = NodeV3_Kind + "." + CRDGroupVersion.String()
	NodeV3_GroupVersionKind = CRDGroupVersion.WithKind(NodeV3_Kind)
)

func init() {
	SchemeBuilder.Register(&NodeV3{}, &NodeV3List{})
}
