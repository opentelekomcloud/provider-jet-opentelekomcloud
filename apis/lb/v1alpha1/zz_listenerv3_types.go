/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type InsertHeadersObservation struct {
}

type InsertHeadersParameters struct {

	// +kubebuilder:validation:Optional
	ForwardELBIP *bool `json:"forwardElbIp,omitempty" tf:"forward_elb_ip,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardedForPort *bool `json:"forwardedForPort,omitempty" tf:"forwarded_for_port,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardedHost *bool `json:"forwardedHost,omitempty" tf:"forwarded_host,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardedPort *bool `json:"forwardedPort,omitempty" tf:"forwarded_port,omitempty"`
}

type ListenerV3Observation struct {
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`
}

type ListenerV3Parameters struct {

	// +kubebuilder:validation:Optional
	AdminStateUp *bool `json:"adminStateUp,omitempty" tf:"admin_state_up,omitempty"`

	// +kubebuilder:validation:Optional
	ClientCATLSContainerRef *string `json:"clientCaTlsContainerRef,omitempty" tf:"client_ca_tls_container_ref,omitempty"`

	// +kubebuilder:validation:Optional
	ClientTimeout *int64 `json:"clientTimeout,omitempty" tf:"client_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultPoolID *string `json:"defaultPoolId,omitempty" tf:"default_pool_id,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultTLSContainerRef *string `json:"defaultTlsContainerRef,omitempty" tf:"default_tls_container_ref,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Http2Enable *bool `json:"http2Enable,omitempty" tf:"http2_enable,omitempty"`

	// +kubebuilder:validation:Optional
	InsertHeaders []InsertHeadersParameters `json:"insertHeaders,omitempty" tf:"insert_headers,omitempty"`

	// +kubebuilder:validation:Optional
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// +kubebuilder:validation:Required
	LoadbalancerID *string `json:"loadbalancerId" tf:"loadbalancer_id,omitempty"`

	// +kubebuilder:validation:Optional
	MemberRetryEnable *bool `json:"memberRetryEnable,omitempty" tf:"member_retry_enable,omitempty"`

	// +kubebuilder:validation:Optional
	MemberTimeout *int64 `json:"memberTimeout,omitempty" tf:"member_timeout,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Required
	ProtocolPort *int64 `json:"protocolPort" tf:"protocol_port,omitempty"`

	// +kubebuilder:validation:Optional
	SniContainerRefs []*string `json:"sniContainerRefs,omitempty" tf:"sni_container_refs,omitempty"`

	// +kubebuilder:validation:Optional
	TLSCiphersPolicy *string `json:"tlsCiphersPolicy,omitempty" tf:"tls_ciphers_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags,omitempty"`
}

// ListenerV3Spec defines the desired state of ListenerV3
type ListenerV3Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ListenerV3Parameters `json:"forProvider"`
}

// ListenerV3Status defines the observed state of ListenerV3.
type ListenerV3Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ListenerV3Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ListenerV3 is the Schema for the ListenerV3s API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,otcjet}
type ListenerV3 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ListenerV3Spec   `json:"spec"`
	Status            ListenerV3Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ListenerV3List contains a list of ListenerV3s
type ListenerV3List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ListenerV3 `json:"items"`
}

// Repository type metadata.
var (
	ListenerV3_Kind             = "ListenerV3"
	ListenerV3_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ListenerV3_Kind}.String()
	ListenerV3_KindAPIVersion   = ListenerV3_Kind + "." + CRDGroupVersion.String()
	ListenerV3_GroupVersionKind = CRDGroupVersion.WithKind(ListenerV3_Kind)
)

func init() {
	SchemeBuilder.Register(&ListenerV3{}, &ListenerV3List{})
}
